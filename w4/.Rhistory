ggplot(aes(x = pscore,
group = diff_group, colour = diff_group, fill = diff_group)) +
geom_density(alpha = I(0.3)) +
xlab("Propensity score") +
scale_fill_viridis_d("Status:", end = 0.99) +
scale_colour_viridis_d("Status:", end = 0.99) +
theme(legend.position = "bottom")
##  Manual IPWE ATE non-normalised
nsw_dw_cpscontrol.trim %<>%
mutate(y1 = treat * re78/pscore,
y0 = (1-treat) * re78/(1-pscore),
ate = y1 - y0)
nsw_dw_cpscontrol.trim %>%
pull(ate) %>%
mean()  #  1598.551      This seems more realistic and much closer to our RCT ATE of 1539.3
## 3 e) Let's normalise weights to estimate the IPWE
# total number of observations in our data set
N <- nrow(nsw_dw_cpscontrol.trim)
## we create inverse pscore, one column for treat (d1)
## and one column for control (d0)
nsw_dw_cpscontrol.trim  %<>%
mutate(d1 = treat/pscore,
d0 = (1-treat)/(1-pscore))
# Then aggregate all inverse pscores
s1 <- sum(nsw_dw_cpscontrol.trim$d1)
s0 <- sum(nsw_dw_cpscontrol.trim$d0)
# our normalising adjustment factor
adj1 <- s1/N
adj0 <- s0/N
# now we calculate the (inverse) weighted effects again
# but divide/ correct every observation by the adjustment factor
nsw_dw_cpscontrol.trim %<>%
mutate(y1 = (treat*re78/pscore)/(adj1),
y0 = ((1-treat)*re78/(1-pscore))/(adj0),
ate.norm = y1 - y0)
nsw_dw_cpscontrol.trim %>%
pull(ate.norm) %>%
mean()  # 1498.21
## Note: If we calculate PS again using the trimmed data, we get different results.
# Previously we first calculated the PS, then trimmed the data
# Let's see the resultsif we again calculate new PS for the trimmed data set
logit_nsw_trim <- glm(treat ~ age + marr + nodegree + black + hisp + re74 + re75 + u74, family = binomial(link = "logit"),
data = nsw_dw_cpscontrol.trim)
# add to data.frame
nsw_dw_cpscontrol.trim %<>%
mutate(pscore_trim = logit_nsw_trim$fitted.values)
nsw_dw_cpscontrol.trim  %<>%
mutate(d1_trim = treat/pscore_trim,
d0_trim = (1-treat)/(1-pscore_trim))
# Then aggregate all inverse pscores
s1_trim <- sum(nsw_dw_cpscontrol.trim$d1_trim)
s0_trim <- sum(nsw_dw_cpscontrol.trim$d0_trim)
# our normalising adjustment factor
adj1_trim <- s1_trim/N
adj0_trim <- s0_trim/N
# now we calculate the (inverse) weighted effects again
# but divide/ correct every observation by the adjustment factor
nsw_dw_cpscontrol.trim %<>%
mutate(y1_trim = (treat*re78/pscore_trim)/(adj1_trim),
y0_trim = ((1-treat)*re78/(1-pscore_trim))/(adj0_trim),
ate.norm_trim = y1_trim - y0_trim)
nsw_dw_cpscontrol.trim %>%
pull(ate.norm_trim) %>%
mean()  # 1637.132   # This is the result for normalised weights if we re=estimate the PS score after trimming the data
## For the PSweight library, we create a ps.formula that summarises what we normally provide to a regression analysis (outcome variable ~ predictors)
## We only inlcude predictors according to our stepAIC optimisation
ps.formula <- treat ~ age + marr + nodegree + black + hisp + re74 + re75 + u74
# we further define our predictors as vector (for next steps)
var.formula <- c('age' , 'marr' ,'nodegree' , 'black','hisp', 're74' , 're75' , 'u74')
## We must provide the PS estimate manually and then zname (treatment variable) and xname = our predictors for the nuisance function and the ps.estimate command
bal.any.pscore <- SumStat(zname='treat', xname =var.formula, ps.estimate = nsw_dw_cpscontrol.trim$pscore, data = nsw_dw_cpscontrol.trim,  weight = c("IPW"))
# Histogram funtion
plot(bal.any.pscore, type = "hist")  # suggests overlap but hard to say how well we matched
# Love plot function
plot(bal.any.pscore, type = "balance") # This is problematic - some red circles are outside the 0.1 standardised mean difference, implying covariates are not sufficiently balanced
######################################################################################################################################################################
#######################  Melbourne Business School- Practice Questions - Causal Analytics - Class 4 2023 Nico Neumann   ##############################################
######################################################################################################################################################################
## clean memory
rm(list=ls())
######################################################################################################################################################################
#######################  Melbourne Business School- Practice Questions - Causal Analytics - Class 4 2023 Nico Neumann   ##############################################
######################################################################################################################################################################
## clean memory
rm(list=ls())
## install packages if missing
if("fixest" %in% rownames(installed.packages()) == FALSE) install.packages("fixest")
if("AER" %in% rownames(installed.packages()) == FALSE) install.packages("AER")
if("ggplot2" %in% rownames(installed.packages()) == FALSE) install.packages("ggplot2")
#################### load libraries (install first if necessary)
library(tidyverse)
library(fixest)
library(AER)
library(ggplot2)
# increase print out
options(max.print=1000000)
## avoid scientific notation
options(scipen=99)
## load data
schooling.df <- read.csv("ak91.csv")
## load data
schooling.df <- read.csv("catholic_school.csv")
## load data
schooling.df <- read.csv("catholic_schools.csv")
## create dummy for final quarter in calendar year
schooling.df <- schooling.df  %>% mutate(q4 = case_when(qob == 4 ~ 1, qob != 4 ~ 0))
View(schooling.df)
######################################################################################################################################################################
#######################  Melbourne Business School- Practice Questions - Causal Analytics - Class 4 2024 Nico Neumann   ##############################################
######################################################################################################################################################################
## clean memory
rm(list=ls())
## install packages if missing
## (1) Define the packages that will be needed
packages <- c( 'tidyverse','PSweight', 'lmtest',  'magrittr','MASS', 'boot', 'ggplot2')
## (2) Install them if not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages])
}
#################### load limath.dfaries (install first if necessary)
library(tidyverse)
library(ggplot2)
library(boot)
library(magrittr)
library(MASS)
library(PSweight)
# increase print out
options(max.print=1000000)
## avoid scientific notation
options(scipen=99)
## load data
math.df <- read.csv("catholic_schools.csv")
##
head(math.df)
## B a) transforming outcome variable?
hist(math.df$math12)   # seems closer to normal distribution
hist(log(math.df$math12))
## B b) balance check for our treatment variable 'catholic'
table(math.df$catholic)
math.df  %>% group_by(catholic) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))   # very imbalanced - only 10% catholic
## B c) let's check our observed covariates (exactly as we did with experimental data)
# Balance by gender
math.df  %>% group_by(catholic, female) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # small differences
# Balance by race
math.df  %>% group_by(catholic, race) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # stronger differences
# Balance by parents marital status in 8th grade
math.df  %>% group_by(catholic, parmar8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # stronger differences
# Balance by student rarely completes homework in grade 8
math.df  %>% group_by(catholic, nohw8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # stronger differences
# Balance by disrupt8
math.df  %>% group_by(catholic, disrupt8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # small differences
# Balance by figh8
math.df  %>% group_by(catholic, fight8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # small differences
# Balance by discrete variable risk to drop
math.df  %>% group_by(catholic, riskdrop8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # stronger differences
## For continuous variables, we can compare the mean for each catholic level
math.df %>% group_by(catholic) %>% summarize(math8 = mean(math8), read8 =mean(read8), faminc8 = mean(faminc8),
fathed8= mean(fathed8), mothed8=mean(mothed8))
## We can interpret education and income as discrete too
# Balance by discrete variable education
math.df  %>% group_by(catholic, fathed8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))
## We can interpret education and income as discrete too
# Balance by discrete variable education
math.df  %>% group_by(catholic, fathed8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))
math.df  %>% group_by(catholic, mothed8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))
math.df  %>% group_by(catholic, faminc8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))
## B d) check common support and balance (indirectly) for continuous variable - overlap of distributions
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = math8,
group = diff_group, colour = diff_group, fill = diff_group)) +
geom_density(alpha = I(0.2)) +
xlab("math score in class 8") +
scale_fill_viridis_d("Status:", end = 0.7) +
scale_colour_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
## income, which is discrete (different income math.dfackets)
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = faminc8,
fill = diff_group)) +
geom_histogram(aes(y = ..density.. /sum(..density..)*100), alpha = 0.5, position = "dodge") +
xlab("family income in class 8") +
ylab("Percentage count") +
scale_fill_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = read8,
group = diff_group, colour = diff_group, fill = diff_group)) +
geom_density(alpha = I(0.2)) +
xlab("read score in class 8") +
scale_fill_viridis_d("Status:", end = 0.7) +
scale_colour_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = mothed8,
fill = diff_group)) +
geom_histogram(aes(y = ..density.. /sum(..density..)*100), alpha = 0.5, position = "dodge") +
xlab("Mother's education") +
ylab("Percentage count") +
scale_fill_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = fathed8,
fill = diff_group)) +
geom_histogram(aes(y = ..density.. /sum(..density..)*100), alpha = 0.5, position = "dodge") +
xlab("Father's education") +
ylab("Percentage count") +
scale_fill_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
## B e)
## formula with all covariates
D.model <- glm(catholic ~ factor(female) + factor(race)  + factor(fight8)+ factor(disrupt8) + factor(fathed8) + factor(mothed8)+ faminc8  + math8 + read8 + factor(nohw8) + factor(parmar8) + factor(riskdrop8), data = math.df, family = binomial(link = 'logit'))
summary(D.model)
summary(D.model)
## C) stratification (subclassification) with not completing hw and disruptive behaviour dummies only
math.df  %<>%
mutate(subclass = case_when(nohw8 == 0 & disrupt8 == 0 ~ 1,
nohw8 == 1 & disrupt8 == 0 ~ 2,
nohw8 == 0 & disrupt8 == 1 ~ 3,
nohw8 == 1 & disrupt8 == 1 ~ 4))
summary(D.model)
strata.boot <- function(data =math.df, index = 1:nrow(math.df)) {
data.bootstrap <- math.df %<>% slice(index)
boot.round.result <- strata.att(data.bootstrap)
return(boot.round.result)
}
## bootstrapping
boot.result <- boot(math.df, strata.boot, R = 100)
boot.result
## bootstrapping
boot.result <- boot(math.df, strata.boot, R = 100)
## create a function using bootstrapping
strata.att <- function(data.analyse){
ey11 <- data.analyse %>%
filter(subclass== 1 & catholic== 1) %$%
mean(math12)
ey10 <- data.analyse %>%
filter(subclass== 1 & catholic== 0) %$%
mean(math12)
ey21 <- data.analyse %>%
filter(subclass== 2 & catholic== 1) %$%
mean(math12)
ey20 <- data.analyse %>%
filter(subclass== 2 & catholic== 0) %$%
mean(math12)
ey31 <- data.analyse %>%
filter(subclass== 3 & catholic== 1) %$%
mean(math12)
ey30 <- data.analyse %>%
filter(subclass== 3 & catholic== 0) %$%
mean(math12)
ey41 <- data.analyse %>%
filter(subclass== 4 & catholic== 1) %$%
mean(math12)
ey40 <- data.analyse %>%
filter(subclass== 4 & catholic== 0) %$%
mean(math12)
diff1 = ey11 - ey10
diff2 = ey21 - ey20
diff3 = ey31 - ey30
diff4 = ey41 - ey40
wt1 <- data.analyse %>%
filter(subclass== 1 & catholic==1) %$%
nrow(.)/N_treated
wt2 <- data.analyse %>%
filter(subclass== 2 & catholic==1) %$%
nrow(.)/N_treated
wt3 <- data.analyse %>%
filter(subclass== 3 & catholic==1) %$%
nrow(.)/N_treated
wt4 <- data.analyse %>%
filter(subclass== 4 & catholic==1) %$%
nrow(.)/N_treated
## (weighted) catholic effect
att = diff1*wt1 + diff2*wt2 + diff3*wt3 + diff4*wt4
return(att)
}
strata.boot <- function(data =math.df, index = 1:nrow(math.df)) {
data.bootstrap <- math.df %<>% slice(index)
boot.round.result <- strata.att(data.bootstrap)
return(boot.round.result)
}
## bootstrapping
boot.result <- boot(math.df, strata.boot, R = 100)
boot.result
## bootstrapping
boot.result <- boot(math.df, strata.boot, R = 100)
## define N_treated = number of treated observations
N_treated <- math.df %>% filter(catholic == 1) %>% nrow()
######################################################################################################################################################################
#######################  Melbourne Business School- Practice Questions - Causal Analytics - Class 4 2024 Nico Neumann   ##############################################
######################################################################################################################################################################
## clean memory
rm(list=ls())
## install packages if missing
## (1) Define the packages that will be needed
packages <- c( 'tidyverse','PSweight', 'lmtest',  'magrittr','MASS', 'boot', 'ggplot2')
## (2) Install them if not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages])
}
#################### load limath.dfaries (install first if necessary)
library(tidyverse)
library(ggplot2)
library(boot)
library(magrittr)
library(MASS)
library(PSweight)
# increase print out
options(max.print=1000000)
## avoid scientific notation
options(scipen=99)
## load data
math.df <- read.csv("catholic_schools.csv")
##
head(math.df)
## B a) transforming outcome variable?
hist(math.df$math12)   # seems closer to normal distribution
hist(log(math.df$math12))
## B b) balance check for our treatment variable 'catholic'
table(math.df$catholic)
math.df  %>% group_by(catholic) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))   # very imbalanced - only 10% catholic
## B c) let's check our observed covariates (exactly as we did with experimental data)
# Balance by gender
math.df  %>% group_by(catholic, female) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # small differences
# Balance by race
math.df  %>% group_by(catholic, race) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # stronger differences
# Balance by parents marital status in 8th grade
math.df  %>% group_by(catholic, parmar8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # stronger differences
# Balance by student rarely completes homework in grade 8
math.df  %>% group_by(catholic, nohw8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # stronger differences
# Balance by disrupt8
math.df  %>% group_by(catholic, disrupt8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # small differences
# Balance by figh8
math.df  %>% group_by(catholic, fight8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # small differences
# Balance by discrete variable risk to drop
math.df  %>% group_by(catholic, riskdrop8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))  # stronger differences
## For continuous variables, we can compare the mean for each catholic level
math.df %>% group_by(catholic) %>% summarize(math8 = mean(math8), read8 =mean(read8), faminc8 = mean(faminc8),
fathed8= mean(fathed8), mothed8=mean(mothed8))
## We can interpret education and income as discrete too
# Balance by discrete variable education
math.df  %>% group_by(catholic, fathed8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))
math.df  %>% group_by(catholic, mothed8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))
math.df  %>% group_by(catholic, faminc8) %>%
summarise(cnt = n()) %>%
mutate(prop = round(cnt / sum(cnt), 3))
## B d) check common support and balance (indirectly) for continuous variable - overlap of distributions
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = math8,
group = diff_group, colour = diff_group, fill = diff_group)) +
geom_density(alpha = I(0.2)) +
xlab("math score in class 8") +
scale_fill_viridis_d("Status:", end = 0.7) +
scale_colour_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
## income, which is discrete (different income math.dfackets)
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = faminc8,
fill = diff_group)) +
geom_histogram(aes(y = ..density.. /sum(..density..)*100), alpha = 0.5, position = "dodge") +
xlab("family income in class 8") +
ylab("Percentage count") +
scale_fill_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = read8,
group = diff_group, colour = diff_group, fill = diff_group)) +
geom_density(alpha = I(0.2)) +
xlab("read score in class 8") +
scale_fill_viridis_d("Status:", end = 0.7) +
scale_colour_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = mothed8,
fill = diff_group)) +
geom_histogram(aes(y = ..density.. /sum(..density..)*100), alpha = 0.5, position = "dodge") +
xlab("Mother's education") +
ylab("Percentage count") +
scale_fill_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
math.df %>%
mutate(diff_group = ifelse(catholic == 1, "Catholic school", "Other school")) %>%
ggplot(aes(x = fathed8,
fill = diff_group)) +
geom_histogram(aes(y = ..density.. /sum(..density..)*100), alpha = 0.5, position = "dodge") +
xlab("Father's education") +
ylab("Percentage count") +
scale_fill_viridis_d("Status:", end = 0.7) +
theme(legend.position = "bottom")
## B e)
## formula with all covariates
D.model <- glm(catholic ~ factor(female) + factor(race)  + factor(fight8)+ factor(disrupt8) + factor(fathed8) + factor(mothed8)+ faminc8  + math8 + read8 + factor(nohw8) + factor(parmar8) + factor(riskdrop8), data = math.df, family = binomial(link = 'logit'))
summary(D.model)
## C) stratification (subclassification) with not completing hw and disruptive behaviour dummies only
math.df  %<>%
mutate(subclass = case_when(nohw8 == 0 & disrupt8 == 0 ~ 1,
nohw8 == 1 & disrupt8 == 0 ~ 2,
nohw8 == 0 & disrupt8 == 1 ~ 3,
nohw8 == 1 & disrupt8 == 1 ~ 4))
## double check
table(math.df$subclass)
## define N_treated = number of treated observations
N_treated <- math.df %>% filter(catholic == 1) %>% nrow()
## create a function using bootstrapping
strata.att <- function(data.analyse){
ey11 <- data.analyse %>%
filter(subclass== 1 & catholic== 1) %$%
mean(math12)
ey10 <- data.analyse %>%
filter(subclass== 1 & catholic== 0) %$%
mean(math12)
ey21 <- data.analyse %>%
filter(subclass== 2 & catholic== 1) %$%
mean(math12)
ey20 <- data.analyse %>%
filter(subclass== 2 & catholic== 0) %$%
mean(math12)
ey31 <- data.analyse %>%
filter(subclass== 3 & catholic== 1) %$%
mean(math12)
ey30 <- data.analyse %>%
filter(subclass== 3 & catholic== 0) %$%
mean(math12)
ey41 <- data.analyse %>%
filter(subclass== 4 & catholic== 1) %$%
mean(math12)
ey40 <- data.analyse %>%
filter(subclass== 4 & catholic== 0) %$%
mean(math12)
diff1 = ey11 - ey10
diff2 = ey21 - ey20
diff3 = ey31 - ey30
diff4 = ey41 - ey40
wt1 <- data.analyse %>%
filter(subclass== 1 & catholic==1) %$%
nrow(.)/N_treated
wt2 <- data.analyse %>%
filter(subclass== 2 & catholic==1) %$%
nrow(.)/N_treated
wt3 <- data.analyse %>%
filter(subclass== 3 & catholic==1) %$%
nrow(.)/N_treated
wt4 <- data.analyse %>%
filter(subclass== 4 & catholic==1) %$%
nrow(.)/N_treated
## (weighted) catholic effect
att = diff1*wt1 + diff2*wt2 + diff3*wt3 + diff4*wt4
return(att)
}
strata.boot <- function(data =math.df, index = 1:nrow(math.df)) {
data.bootstrap <- math.df %<>% slice(index)
boot.round.result <- strata.att(data.bootstrap)
return(boot.round.result)
}
## bootstrapping
boot.result <- boot(math.df, strata.boot, R = 100)
boot.result
